#!/usr/bin/env raku

use File::Find;
use Git::Status;
use App::Gitstatus;

if not @*ARGS.elems {
    print qq:to/HERE/;
    Usage: {$*PROGRAM.basename} <dir> [...options...]

    Checks the Git status of all directories under
    directory 'dir' which are 'dirty' (i.e., having
    a non-zero 'Git::Status') and lists those
    directories.

    Options:
      all        - report details of all dirty directories
      first      - report the first directory only
      last       - report the last directory only
      ignore=/X/ - ignore directory names satisfying regex /X/
      select=/X/ - select directory names satisfying regex /X/
      debug

    HERE
    exit;
}

my $dir = @*ARGS.shift;
if not $dir.IO.d {
    die "FATAL: The first argument '$dir' is not a directory as required.";
}

my $debug   = 0;
my $details = 0;
my $all     = 0;
my $first   = 0;
my $last    = 0;
my $ignore  = 0;
my $select  = 0;
my $regex;

for @*ARGS {
    when /^d/ { ++$debug             }
    when /^a/ { ++$all;   ++$details }
    when /^f/ { ++$first; ++$details }
    when /^l/ { ++$last;  ++$details }
    when /^i[gnore]? '=/' (\N+) '/' $/ {
        $regex = ~$0;
        ++$ignore; ++$details;
    }
    when /^s[elect]? '=/' (\N+) '/' $/ {
        $regex = ~$0;
        ++$select; ++$details;
    }
    default {
        die  "FATAL: Unknown arg '$_'";
    }
}

if $debug {
   say "DEBUG: regex = '$regex'";
}

my @search-dirs;
my @dirs;
if $select {
   @search-dirs = find :$dir, :type('dir'), :name(/<$regex>/);
}
elsif $ignore {
   @search-dirs = find :$dir, :type('dir'), :exclude(/<$regex>/);
}
else {
   @search-dirs = find :$dir, :type('dir');
}

if $first and @search-dirs {
   @dirs.push: @search-dirs.head;
}
elsif $last and @search-dirs  {
   @dirs.push: @search-dirs.tail;
}
else {
   @dirs = @search-dirs;
}

my $nd = @dirs.elems;
if not $nd {
   say "Found $nd directories under directory '$dir'.";
   exit;
}

my $ng = 0;
my @dirty;
for @dirs -> $d {
    next unless "$d/.git".IO.d;
    my $gs = Git::Status.new: :directory($d);
    # possible results
    my @add     = $gs.added;
    my @del     = $gs.deleted;
    my @mod     = $gs.modified;
    my @untrack = $gs.untracked;
    if $gs.gist {
        @dirty.push: $d;
        next unless $details;

        say "  Found git repo at dir '$d'";
        say "    added    : $_" for @add;
        say "    deleted  : $_" for @del;
        say "    modified : $_" for @mod;
        say "    untracked: $_" for @untrack;
        ++$ng;
        say "    directory is dirty";
    }
}
if not $ng {
     say "All directories are clean repos";
}
else {
     say "Found $ng dirty git repos:";
     say "  $_" for @dirty;
}
